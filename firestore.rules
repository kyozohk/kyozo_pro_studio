/**
 * @fileoverview Firestore Security Rules for the application.
 *
 * Core Philosophy:
 * This ruleset enforces a multi-tenant security model where tenants (organizations) own communities,
 * and users have profiles. Users can be members of communities with different roles. The rules prioritize
 * tenant-level access control, ensuring that only authorized tenants can manage their own data.
 *
 * Data Structure:
 * - /users/{userId}: Stores public user profile information.
 * - /tenants/{tenantId}: Stores tenant (organization) information. tenantId is the UID of the owner.
 * - /tenants/{tenantId}/communities/{communityId}: Stores communities created by a specific tenant.
 * - /tenants/{tenantId}/communities/{communityId}/memberships/{memberId}: Stores membership information for users within a specific community.
 *
 * Key Security Decisions:
 * - Users can only read and write their own profile data.
 * - Only the tenant owner can create, update, or delete tenant information.
 * - Only the tenant owner can create communities under their tenant.
 * - Community updates and deletes are restricted to the tenant owner.
 * - Membership management is restricted to community administrators.
 *
 * Denormalization for Authorization:
 * - Community documents include a `createdBy` field to indicate the tenant (user ID) that created it. This avoids the need to query the parent tenant document for authorization.
 *
 * Structural Segregation:
 * - Private user data (e.g., settings) is stored under the `/users/{userId}` path, while public community data is stored under `/tenants/{tenantId}/communities/{communityId}`. This allows for different access control policies for each type of data.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Controls access to user profile information.
     * @path /users/{userId}
     * @allow (get, create, update, delete, list) User with matching userId.
     * @deny (get, create, update, delete, list) Any other user.
     * @principle Enforces document ownership for user profiles.
     */
    match /users/{userId} {
      function isOwner(userId) {
        return request.auth != null && request.auth.uid == userId;
      }
      allow get: if isSignedIn() && isOwner(userId);
      allow list: if false;
      allow create: if isSignedIn() && isOwner(userId) && request.resource.data.userId == userId;
      allow update: if isSignedIn() && isOwner(userId) && resource.data.userId == userId;
      allow delete: if isSignedIn() && isOwner(userId) && resource.data.userId == userId;
    }

    /**
     * @description Controls access to tenant information.
     * @path /tenants/{tenantId}
     * @allow (get, create, update, delete) Tenant owner with matching tenantId.
     * @allow list: if false.
     * @deny (get, create, update, delete) Any other user.
     * @principle Enforces document ownership for tenants.
     */
    match /tenants/{tenantId} {
      function isOwner(tenantId) {
        return request.auth != null && request.auth.uid == tenantId;
      }
      function isExistingOwner(tenantId) {
        return isOwner(tenantId) && resource != null;
      }
      allow get: if isSignedIn() && isOwner(tenantId);
      allow list: if false;
      allow create: if isSignedIn() && isOwner(tenantId) && request.resource.data.tenantId == tenantId;
      allow update: if isExistingOwner(tenantId) && request.resource.data.tenantId == tenantId;
      allow delete: if isExistingOwner(tenantId) && request.resource.data.tenantId == tenantId;

      /**
       * @description Controls access to communities created by a tenant.
       * @path /tenants/{tenantId}/communities/{communityId}
       * @allow create: Tenant owner can create new communities.
       * @allow get, list: Any signed-in user can read communities.
       * @allow update, delete: Only the tenant owner can modify or delete communities.
       * @principle Enforces tenant ownership for community management.
       */
      match /communities/{communityId} {
        function isOwner(tenantId) {
          return request.auth != null && request.auth.uid == tenantId;
        }
        function isExistingOwner(tenantId) {
            return isOwner(tenantId) && resource != null;
        }
        allow get, list: if isSignedIn();
        allow create: if isSignedIn() && isOwner(tenantId) && request.resource.data.createdBy == tenantId;
        allow update: if isExistingOwner(tenantId) && request.resource.data.createdBy == resource.data.createdBy;
        allow delete: if isExistingOwner(tenantId) && request.resource.data.createdBy == resource.data.createdBy;

        /**
         * @description Controls access to community memberships.
         * @path /tenants/{tenantId}/communities/{communityId}/memberships/{memberId}
         * @allow get, list: Any signed-in user can view memberships.
         * @allow create: Only the tenant owner can create new memberships.
         * @allow update, delete: Only the tenant owner can modify or delete memberships.
         */
        match /memberships/{memberId} {
          function isTenantOwner(tenantId) {
            return request.auth != null && request.auth.uid == tenantId;
          }
          function isExistingTenantOwner(tenantId) {
              return isTenantOwner(tenantId) && resource != null;
          }
          allow get, list: if isSignedIn();
          allow create: if isSignedIn() && isTenantOwner(tenantId);
          allow update: if isExistingTenantOwner(tenantId);
          allow delete: if isExistingTenantOwner(tenantId);
        }
      }
    }

    function isSignedIn() {
      return request.auth != null;
    }
  }
}